# Overview
## Actors and tasks

TODO: О том что актеры в процессе свой работы пораждают решения. Частью решения могут быть задачи другим актерам и
самому
себе. О зависимостях между задачами. О том что зависимости разруливает Taskurotta выдавая актерам только те задачи,
которые готовы для исполнгения. Пример на пальцах из жизни о стеке задач с зависимостями. J том,
что концентрируем логику управления процесса в координаторах. Деление на координаторов и исполнителей. Координатор
как исполнитель = подпроцесс.

## Distributed architecture

В настоящий момент основной является клиент-серверная архитектура. Сервера образуют кластер с расшаренной памятью и средой исполнения с помощью [Haselcast](http://hazelcast.com/). Клиенты могут обращяться к любому из серверов напрямую или через load balancer. 

## Fine Modularization of Backend

TODO: Все в памяти удержать нельзя - нужно сбрасывать излишки в базу. База должна быть шустрая и хорошо масштабируемая.
Транзакционность это дорого. Выбираем решение при котором старт процесса логируется в оракл. А остальные данные в
MongoDB.

Говорим о том что из за модульности можно собрать различные конфигурации:

- все в памяти. Для быстрого локального тестирования.
- все в hazelcast big memory. Для систем не требующих восстановления состояния после сбоя. Нужно выделить достаточно
памяти. Самая быстрая конфигурация.
- все в hazelcast + mongodb как хранилище. В mongodb вытисняется то что не помещается в память и используется при
необходимости. Для систем требующих восстановления состояния после сбоя. Если есть опыт поддержки mongodb
обеспечивающий необходимый уровень надежности хзранения данных.
- все в hazelcast + mongodb + oracle. В oracle синхронно сохраняется вся информация о процессе при его старте. Если
клиент не получил ошибку то он уверен что процесс запущен. Высокая надежность в ущерб скорости на этапе старта
процесса.

Кроме этого можно собирать без транспорта. Т.е. кластер будет подыматься вместе с актерами в одной JVM.

# Actors API

## Actor Identification

TODO: Имя и версия интерфейса. Отличие версии интерфейса от версии реализации.

## Worker Implementation

### Worker Interface

TDOD: Про зависимости между интерфейсом и реализацией. 

### Worker Implementation

Координатор не должен зависить от библиотек,
необходимых для работы исполнителей. Только от интерфейсов. Иначе в случае использования maven в качестве менеджера зависимостей, Координатор будет зависеть от всех библиотек, необходимых для работы Исполнителя. Это не верно. Координатору не важна реализация Исполнителя. Ему важен только контракт взаимодействия с ним - т.е. его интерфейс. 

Чтобы избежать не нужного связывания можно поместить интерфес Исполнителя в одну библиотеку а реализацию в другую. Реализация будет зависить от интерфейса, что корректно. А координатор, только от интерфейса.

Существует еще одна проблема связывания. Возможно мы хотим один из существующих сервисов определить как Исполнителя в инфраструктуре Taskurotta. Для этого нам понадобиться определить его контракт (интерфейс) и его версию. Определдение производится с помощью аннотации @Worker у интерфейса. Эта аннотация входит в модуль проекта Taskurotta. Если мы существующий сервис определим как реализацию этого интерфейса, то у него появится зависимоть на проект Taskurotta что не желательно. Для избежания данного связывания можно определить реализацию интерфейса Исполнителя в виде прокси, который принимает задачи по контракту с стороны инфраструктуры Taskurotta и вызывает соответствующие методы существующего сервиса.


## Decider Implementation

### Decider Interface

TODO: About @Decider and @Start annotations

### Actors Client Stubs

TODO: Workers and Deciders client interfaces. Why, how create and use. Promises.

### @Asynchronous methods

TODO: decider stub

### @AcceptFail

## Taskurotta Bootstrap

Это контейнер для актеров выполняющий следующие задачи:

- Создает транспортный слой для взаимодействия с серверами Taskurotta
- Создает прикладной слой со всеми задекларированными актерами
- Создает и запускает пул рабочих потоков, которые получают задачи от серверов Taskurotta через транспортный слой, передают задачи на выполнение через прикладной слой и возвращают результат на сервера.
- Есть возможность определить Profiler, который будет проксировать вызовы рабочих потоков к транспортному и прикладному слою. С помощью этого, например, можно реализовать мониторинг или влиять на интенсивность взаимодействия с сервером в зависимости от количества задач в очередях для актеров.

- 
Для использования модуля нужно:

TODO: вставить примеры из проекта getstarted. По каждому пункту надо подробно опистать.

- добавить зависимость от него в pom.xml
- добавить плагин для сбора исполняемого jar файла (можно и без этого если указывать список библиотек при старте)
- определить инициализацию актеров руками или с помощью IoC контейнера
- определить в конфигурационном файле следующие блоки:
  - тип транспортного слоя и параметры соединения с серверами.
  - параметры инициализации прикладного слоя
  - параметры пула рабочих оптоков для каждого актера
  - параметры и тип Profiler


# Taskurotta server

## Запуск различных конфигурация

## Использование памяти

## Настройка сборки мусора

# Web Console

## Queues

## View particular processes and tasks

## Management of dead processes

## Metrics

## Process Scheduler
  
