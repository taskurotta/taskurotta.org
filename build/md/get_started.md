# Введение

Это руководство даст пошаговое представление о создании простого проекта. Представим себе, что перед нами стоит следующая
задача:

> Необходимо разработать приложение, отсылающее строковое сообщение пользователю.
> На вход мы получаем Id пользователя и набор символов. Из его профиля (по Id) достаем
> данные о предпочтении - получать сообщения по email или номеру телефона. Номер телефона и
> email также доступны в профиле. Далее отправляем сообщение нужным транспортом. В случае, если
> отправка не удалась (по причине не верного адреса или номера), необходимо отметить это в профиле
> для предотвращения повторных попыток в будущем.

Добавим еще к этому не функциональное требование, о том, что сервисы отправляющие сообщения уже существуют,
находятся в других подсетях и их нужно переиспользовать.

## Общее представление в двух словах <section id="overview"> &nbsp;</section>

STF позволяет реализовывать компоненты системы (Актеров), взаимодействующих между собой привычным для
разработчика способом - путем вызовов методов друг друга, но в асинхронной манере. Актеры делятся на два вида -
Исполнителей и Координаторов. Исполнители должны четко выполнять поставленные перед ними задачи. Они
представляют собой максимально независимые модули, и соответственно - максимально переиспользуемые. Исполнители
могут взаимодействовать с внешним миром (любые потоки ввода вывода) выполняя задачу таким образом и так долго, как этого
требуется. С другой стороны, Координаторы не выполняют задач, связанных с внешним миром. Они должны отрабатывать как
можно быстрее и не спотыкаться на прямом взаимодействии с БД, сетью и другими потенциально не стабильными компонентами.
Их обязанность ставить задачи исполнителям, координировать их действия и тем самым обеспечить реализацию (описание) процесса.
Координаторы могут ставить задачи другим координаторам, реализуя парадигму переиспользуемых подпроцессов.

## Чуть глубже в трех словах <section id="overview_deep"> &nbsp;</section>

Задача Координатора как можно быстрее раздать известные в данный момент задачи. Т.е. он не должен блокироваться на
ожидании результата. Он должен построить граф зависимостей между известными ему задачами и при необходимости
сформировать асинхронные точки определения дальнейших действий. Как этого достичь, давайте рассмотрим на синтетическом примере.

<blockquote>
    Предположим, что мы должны получить выписку из учетной системы, подписать ее, и отправить пользователю на email.
</blockquote>

Как видно из условия задачи, нет никаких условных ветвлений. Все задачи выполняются последовательно
и зависят одна от другой. В данном случае дирижер процесса должен сделать следующее:

1. Запросить выписку.
2. Дождаться ее выполнения.
3. Передать выписку на подпись.
4. Дождаться подписанного документа.
5. Передать подписанный документ в сервис отправки email.

Кодировать данную последовательность действий с помощью автомата состояний, методами изменений одного сообщения несколькими
исполнителями и другими привычными, но костлявыми способами мы не будем. Сделаем это просто и красиво с помощью
сущности Promise и нашей системы, следящей за действиями Координатора.

    Promise<Statement> pStatement = statementService.createStatement(requestAttributes);
    Promise<SignedStatement> pSignedStatement = signService.signStatement(pStatement);
    emailService.sendEmail("user@example.com", "This is your statement", pSignedStatement);

В примере видно, что в результате вызова сервисов мы получаем не реальный объект, а некий Promise - ссылку на результат
выполнения задачи. Этот Promise мы можем передавать в качестве аргумента другим сервисам (т.е. задачам). Вызовы других
сервисов будут перехвачены системой (т.е. реального синхронного вызова не произойдет) и выстроена зависимость между ними.
Задачи не поступят на выполнение к сервисам до тех пор, пока все их аргументы типа Promise не будут готовы, т.е. пока
не будут выполнены все необходимые предварительные задачи.

Таким образом, дирижирование процессом выполняется совместно координатором и нашей системой. Координатор выстраивает
зависимости между задачами, а система берет на себя, кроме всего прочего, функцию ожидания выполнения предварительных задач
и последующего запуска зависимых от них задач.

Давайте теперь усложним пример и раскроем, что такое асинхронные точки определения дальнейших действий.

<blockquote>
    Предположим, что в дополнение к описанному примеру необходимо убедиться в том, что полученная выписка это не отказ
    в предоставлении сведений. И отсылать выписку по почте, только если это не отказ. Напоминаю, что пример
    искусственный.
</blockquote>

В данном случае необходимо между получением выписки и дальнейшими действиями проанализировать результат. Т.е.
дождаться выполнения задачи, произвести анализ и в зависимости от результата, начинать подпись с отправкой или нет. Для решения
такой проблемы у координатора есть возможность создать задачу на самого себя - т.е. точку определения дальнейших действий,
в которую передать необходимые Promise. Ниже представлено как это выглядит.

    public void start() {
        Promise<Statement> pStatement = statementService.createStatement(requestAttributes);
        asynch.waitStatement(pStatement)
    }

    @Asynchronous
    public void waitStatement(Promise<Statement> pStatement) {
        if (!pStatement.get().isReject()) {
            Promise<SignedStatement> pSignedStatement = signService.signStatement(pStatement);
            emailService.sendEmail("user@example.com", "This is your statement", pSignedStatement);
        }
    }

Метод start() - это старт процесса. Далее идет постановка двух задач. Первая на получение выписки, а вторую задачу
Координатор ставит сам себе для последующего анализа выписки (вызов метода waitStatement). Таким образом Координатор
как бы ждет решения первой задачи, но без блокировки. Как только задача решена, система STF вызывает метод координатора
waitStatement, передавая в него готовый Promise объект, из которого можно получить реальные данные методом get().
После определения того, что получен не отказ в предоставлении сведений (<code>if (!pStatement.get().isReject())</code>),
мы ставим следующие задачи.

С помощью точек определения дальнейших действий можно реализовать различные поведения процесса:

- распараллеливание на различные ветки;
- дальнейшее слияние независимых потоков процесса в одной точке с помощью проброса Promise и @NoWait аннотации
(см. документацию TODO);
- асинхронную рекурсию;
- распараллеливание выполнения однотипных задач, например проверки ЭЦП всех файлов и ожидания результатов выполнения в
одной точке принятия решений;
- и т.д.

P.S.: Вызов задачи waitStatement происходит через объект asynch. Это искусственный объект, перехватывающий вызов, но реально
не вызывающий метод waitStatement. Нам нужно поставить задачу, а не вызвать ее синхронно. Можно сделать перехват и без
этого объекта, но это будет уже тема в четырех словах. Не будем пока углубляться в джунгли и приступим непосредственно
к разработке...


## Настройка Maven <section id="maven-dep"> &nbsp;</section>

Для начала работы нам необходимо добавить зависимость от модуля wf-core в проект.

    <dependency>
        <groupId>ru.taskurotta</groupId>
        <artifactId>wf-core</artifactId>
        <version>${ru.taskurotta.version}</version>
    </dependency>

В этом модуле содержатся все необходимые классы для разработки и unit тестирования Исполнителей и Координаторов.

## Создание Исполнителя <section id="worker-new"> &nbsp;</section>

Так как по сценарию у нас уже есть Исполнители для отправки email и sms, то нам остается только создать Исполнителя для работы
с профилем. У данного Исполнителя две задачи:

1. Вернуть профиль по идентификатору пользователя.
2. Сделать в профиле отметку о невозможности отправки сообщений для конкретного пользователя.

Начинаем с объявления его интерфейса. С этим интерфейсом будет работать Координатор. Здесь и далее, для компактности
опущены комментарии и другие не существенные части кода.

    @Worker
    public interface ProfileWorker {

        public Profile getUserProfile(long userId);
        public void blockNotification(long userId);
    }

Аннотация @Worker определяет этот интерфейс как Исполнителя. У аннотации есть необязательные атрибуты определяющие аго
имя и версию. По умолчанию, именем является полное имя интерфейса, а версия - "1.0". Исполнители различных версий могут
одновременно работать для разных процессов без каких либо конфликтов.

Перейдем к реализации интерфейса.

    public class ProfileWorkerImpl implements ProfileWorker {

        private ProfileManager profileManager;

        @Override
        public Profile getUserProfile(long userId) {
            return profileManager.getProfileById(userId);
        }

        @Override
        public void blockNotification(long userId) {
            profileManager.setDeliveryType(userId, Profile.DELIVERY_TYPE.BLOCKED);
        }
    }

Тут мы опустили инициализацию менеджера профилей (ProfileManager). Он может работать с БД, LDAP или другим реестром. Данный
пример нам показывает, что Исполнитель получает задачи (вызовы) и делегирует их реальному модулю.

На этом создание Исполнителя завершается.

## Объявление способа взаимодействия <section id="worker-client"> &nbsp;</section>

Для решения поставленной перед нами задачи, Координатор должен передать ссылку на еще не полученный профиль
(объект Promise) в точку определения дальнейших действий. Там он выберет транспорт или не будет ничего отсылать,
если отправка сообщений для данного пользователя уже заблокирована.

Однако интерфейс исполнителя, как и сам исполнитель, получают и отдают результат синхронно, а потому не имеют в декларации
результатов выполнения в виде объекта Promise, а возвращают чистый объект данных. Это и правильно. Исполнитель не должен знать
как его используют. Например, наш Исполнитель по получению профиля можно использовать если уже известен
идентификатор пользователя, или если он не известен и нужно передать ссылку на другую задачу, которая этот идентификатор
откуда-то получит. Таким образом мы приходим к интерфейсу взаимодействия с Исполнителем. Этот интерфейс определяет сам
Координатор для своих нужд. Т.е. он определяется в пакете (проекте) Координатора. Добавим интерфейс взаимодействия
с Исполнителем для работы с профилем:

    @WorkerClient(worker = ProfileWorker.class)
    public interface ProfileWorkerClient {

        public Promise<Profile> getUserProfile(long userId);
        public void blockNotification(long userId);
    }

Мы видим интерфейс помеченный аннотацией @WorkerClient. Параметр аннотации ссылается на класс реального интерфейса Исполнителя. Таким
образом устанавливается связь между существующим интерфейсом и необходимым интерфейсом для конкретного Координатора.
Назовем этот интерфейс "клиентским интерфейсом Исполнителя". Этот клиентский интерфейс должен содержать все необходимые
координатору методы (можно не объявлять не используемые) и с идентичной сигнатурой аргументов. Любой аргумент может
быть типом Promise, если требуется передавать в качестве аргумента результат еще не завершенной задачи.

## Создание Координатора <section id="decider-new"> &nbsp;</section>

Теперь переходим к самому интересному - созданию координатора. Для начала ниже представлен интерфейс координатора,
используя который клиенты STF будут запускать нужные им процессы.

    @Decider
    public interface NotificationDecider {

        @Execute
        public void sendMessage(long userId, String message);
        }
    }

Этот интерфейс определен как @Decider - т.е. как Координатор. У этой аннотации есть те же свойства, что и у аннотации
@Worker - имя и версия. По умолчанию за имя берется полное имя интерфейса, а за версию - "1.0".

Метод sendMessage помечен как @Execute. Это означает что через данный метод можно запускать процесс.

Теперь переходим к реализации координатора

    public class NotificationDeciderImpl implements NotificationDecider {

        private static final Logger logger = LoggerFactory.getLogger(NotificationDeciderImpl.class);

        private ProfileWorkerClient userProfile;
        private EmailWorkerClient emailTransport;
        private SMSWorkerClient smsTransport;
        private NotificationDeciderImpl asynch;

        @Override
        public void sendMessage(long userId, String message) {

            Promise<Profile> profilePromise = userProfile.getUserProfile(userId);
            Promise<Boolean> sendResultPromise = asynch.sendToTransport(profilePromise, message);
            asynch.blockOnFail(userId, sendResultPromise);
        }

        @Asynchronous
        public Promise<Boolean> sendToTransport(Promise<Profile> profilePromise, String message) {

            Profile profile = profilePromise.get();

            switch (profile.getDeliveryType()) {
                case SMS: {
                    return smsTransport.send(profile.getPhoneNumber(), message);
                }
                case EMAIL: {
                    return emailTransport.send(profile.getEmail(), message);
                }
            }

            return Promise.asPromise(Boolean.TRUE);
        }


        @Asynchronous
        public void blockOnFail(long userId, Promise<Boolean> sendResultPromise) {

            if (!sendResultPromise.get()) {
                userProfile.blockNotification(userId);
            }
        }
    }

В данном коде мы также опустили инициализацию приватных объектов. Полный и работающий код примера можно посмотреть в
пакете wf-example. Тут только отметим, что значения приватных полей получаются через специальную фабрику прокси объектов
для Координатора.

В  примере реализации есть две точки ожидания результатов выполнения незавершенных задач Координатором. Это метод
sendToTransport и blockOnFail. Данные методы будут вызваны только тогда, когда все их аргументы типа Promise будут готовы,
т.е. выполнены соответствующий задачи.

Объекты полей типа EmailWorkerClient и SMSWorkerClient также являются клиентскими интерфейсами к соответствующим Исполнителям.
Их инициализацию можно также посмотреть в проекте wf-example.

На данный момент у нас есть все реализованные Исполнители и Координатор. Перейдем непосредственно к запуску Актеров
(т.е. Исполнителей и Координаторов).

## Модуль запуска <section id="wf-bootstrap"> &nbsp;</section>

Выполнение задач может происходить как внутри серверов приложений, так и в виде отдельного java
приложения (*данный пример использует вариант отдельного приложения из модуля wf-bootstrap).
Что делает отдельное приложение:

- Регистрируется на сервере STF.
- Запускает пул из N потоков для выполнения задач.
- Получает задачи от серверов STF.
- Запускает их выполнение.
- Пересылает результат серверу STF.

Для запуска отдельного java приложения используется пакет wf-bootstrap, а конкретнее - класс ru.taskurotta.bootstrap.Main .
Ему в качестве аргумента нужно передать местонахождение файла конфигурации в формате YAML.

Рассмотрим файл конфигурации.

## Настройка приложения <section id="config"> &nbsp;</section>

Файл конфигурации в формате YAML выглядит следующим образом:

    runtime:
      - MainRuntimeConfig:
          class: ru.taskurotta.spring.configs.RuntimeConfigPathXmlApplicationContext
          instance:
            context: RuntimeBeans.xml

    spreader:
      - MainTaskSpreaderConfig:
          class: ru.taskurotta.spring.configs.SpreaderConfigPathXmlApplicationContext
          instance:
            context: SpreaderBeans.xml
            properties:
              userId: 10
              message: "Hello!"
              count: 1

    actor:
      - NotificationDecider:
          actorInterface: ru.taskurotta.example.decider.NotificationDecider
          runtimeConfig: MainRuntimeConfig
          spreaderConfig: MainTaskSpreaderConfig
          count: 1

      - ProfileWorker:
          actorInterface: ru.taskurotta.example.workers.ProfileWorker
          runtimeConfig: MainRuntimeConfig
          spreaderConfig: MainTaskSpreaderConfig
          count: 1

Данная конфигурация определяет, что в одном приложении работают совместно Координатор (NotificationDecider) и Исполнитель
(ProfileWorker). Секция actor определяет этих Актеров. По порядку элементов секции:

1. actorInterface - интерфейс Актера.
2. runtimeConfig - имя конфигуратора инициализирующего и далее предоставляющего для работы экземпляр объекта Актера.
3. spreaderConfig - конфигурация модуля взаимодействующего с серверами STF для получения задач и регистрации результата
их выполнения.
4. count - количество потоков, получающих задачи для актеров и запускающих их выполнение. Т.е. фактически - количество
одновременно работающих актеров.

Секции runtime и spreader специфичны для конкретной реализации контекста выполнения. В данном руководстве мы
их описание опустим. См. соответствующие разделы документации (TODO).

В приведенной выше конфигурации описаны два Актера, которые будут работать одновременно в рамках одной JVM. Строго
говоря, так делать не рекомендуется. Лучше сделать две конфигурации и иметь два приложения - для нашего
Исполнителя и Координатора. Далее запускать и останавливать их независимо, возможно на разных машинах, и в необходимом
количестве. Допускается такая группировка нескольких Актеров в одной конфигурации для тестовых целей или для
экономии памяти.

## Fat Jar <section id="fat-jar"> &nbsp;</section>

С помощью плагинов maven-jar-plugin и maven-shade-plugin мы создаем единый jar файл включающий в себя все необходимые
библиотеки. Это исполняемый jar файл, который можно просто запустить командной <code>java -jar {mainClass}</code> и
так же легко остановить процесс средствами операционной системы.

Таким образом наши Актеры будут очень близки к обычным процессам ОС. Их можно легко перемещать по разным машинам руками,
или автоматически для управления нагрузкой в светлом-присветлом будущем.

Подробнее об использовании плагинов см. в документации в разделе Fat Jar (TODO)

## Запуск приложения <section id="run"> &nbsp;</section>

Наконец мы имеем один jar файл с нашим приложением и конфигурационный файл для него. Остается только запустить приложение:

    java -jar wf-example-0.1.0-SNAPSHOT.jar -f wf-config.yaml

Ниже приведем результат запуска демонстрационного приложения из модуля wf-example. Данный модуль реализует поставленную
перед нами задачу и содержит всех необходимых Актеров. Это полезно для изучения и быстрого проведения экспериментов при
изучении STF. Средой выполнения Актеров выбран тип STF для работы в памяти (без центральных серверов) и соответствующие
реализации интерфейсов указаны в конфигурации. Однако при этом используется такая же как и в продуктиве логика
асинхронных вызовов, логика разрешения зависимостей между задачами и сериализация/десериализация клиент-серверных
коммуникационных пакетов. Сервер в данном случае расположен в памяти.

Лог работы приложения:

    1798 [pool-2-thread-1] INFO  ru.taskurotta.example.decider.NotificationDeciderImpl - .sendMessage(userId = [10],
                    message = [Hello!])
    1810 [pool-3-thread-1] INFO  ru.taskurotta.example.workers.ProfileWorkerImpl - .getUserProfile(userId = [10])
    1832 [pool-2-thread-1] INFO  ru.taskurotta.example.decider.NotificationDeciderImpl - .sendToTransport(profilePromise
                    = [Promise{id=4e6deb2d-b9a2-43d0-9f21-459a77807fa1, isReady=true, value=Profile{id=10, email='test@d
                    omain.com', phoneNumber='1234567890', deliveryType='SMS'}}], message = [Hello!])
    1833 [pool-5-thread-1] INFO  ru.taskurotta.example.workers.SMSWorkerImpl - .send(phoneNumber = [1234567890], message
                    = [Hello!])
    1835 [pool-2-thread-1] INFO  ru.taskurotta.example.decider.NotificationDeciderImpl - .blockOnFail(userId = [10], sen
                    dResultPromise = [Promise{id=14d3d690-4636-432e-9d1b-5e1f87a93073, isReady=true, value=true}])

По логу видно, что каждый Актер выполнялся своим пулом потоков. Порядок выполнения задач соответствует готовности их
аргументов.

На этом мы заканчиваем первое знакомство. Для более глубокого изучения вам предоставляется подробная документация (TODO).
